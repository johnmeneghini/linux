# Call Graph for fc_rport_set_marginal_state Function

## Overview
`fc_rport_set_marginal_state` is a sysfs device attribute store function in the FC (Fibre Channel) transport layer that allows userspace to change the state of FC remote ports between Online and Marginal states. **Enhanced with NVMe-FC integration** to synchronize port states across both SCSI and NVMe-FC protocols when they share the same physical FC infrastructure.

**Location**: `drivers/scsi/scsi_transport_fc.c:1222`

## Call Graph

### Callers (Top-down)
```
Userspace
│
├── write() system call to /sys/class/fc_rport/rport-X:Y-Z/port_state
│
├── VFS layer (fs/sysfs/)
│   └── sysfs_kf_write()
│       └── dev_attr_store()
│           └── device_attr_rport_port_state.store()
│               └── fc_rport_set_marginal_state()  ← TARGET FUNCTION
```

### Function Implementation Analysis
```c
static ssize_t fc_rport_set_marginal_state(struct device *dev,
                                          struct device_attribute *attr,
                                          const char *buf, size_t count)
```

### Direct Function Calls (Callees)
```
fc_rport_set_marginal_state()
├── transport_class_to_rport(dev)
│   └── dev_to_rport(dev->parent)  [macro in include/scsi/scsi_transport_fc.h:398]
│       └── container_of(dev->parent, struct fc_rport, dev)
│
├── get_fc_port_state_match(buf, &port_state)
│   └── [Generated by fc_enum_name_match macro at line 168]
│   └── Searches fc_port_state_names[] table for string match
│       └── strncmp() [from standard library]
│
└── **NEW: NVMe-FC Integration** (when CONFIG_NVME_FC is enabled)
    ├── rport_to_shost(rport)  [macro in include/scsi/scsi_transport_fc.h:400]
    │   └── dev_to_shost(rport->dev.parent)
    │
    ├── fc_host_port_name(shost)  [macro in include/scsi/scsi_transport_fc.h:594]
    │   └── Gets local port WWPN from SCSI host
    │
    ├── nvme_fc_lport_from_wwpn(local_wwpn)  [NEW FUNCTION]
    │   ├── spin_lock_irqsave(&nvme_fc_lock, flags)
    │   ├── list_for_each_entry(lport, &nvme_fc_lport_list, port_list)
    │   ├── nvme_fc_lport_get(lport)  [reference counting]
    │   └── spin_unlock_irqrestore(&nvme_fc_lock, flags)
    │
    ├── nvme_fc_fpin_set_state(lport, rport->port_name, marginal)  [ENHANCED]
    │   ├── nvme_fc_rport_from_wwpn(lport, wwpn)
    │   ├── spin_lock_irq(&rport->lock)
    │   ├── list_for_each_entry(ctrl, &rport->ctrl_list, ctrl_list)
    │   │   ├── set_bit(NVME_CTRL_MARGINAL, &ctrl->ctrl.flags)    [if marginal=true]
    │   │   └── clear_bit(NVME_CTRL_MARGINAL, &ctrl->ctrl.flags)  [if marginal=false]
    │   ├── spin_unlock_irq(&rport->lock)
    │   └── nvme_fc_rport_put(rport)
    │
    └── nvme_fc_lport_put(lport)  [cleanup reference]
```

## Detailed Analysis

### 1. **NEW: Enhanced State Transition Logic**

#### Online → Marginal Transition:
```c
if (rport->port_state == FC_PORTSTATE_ONLINE) {
    rport->port_state = port_state;
    
    #if (IS_ENABLED(CONFIG_NVME_FC))
    // Cross-layer integration: notify NVMe-FC layer
    struct Scsi_Host *shost = rport_to_shost(rport);
    u64 local_wwpn = fc_host_port_name(shost);
    
    lport = nvme_fc_lport_from_wwpn(local_wwpn);
    if (lport) {
        nvme_fc_fpin_set_state(lport, rport->port_name, true);
        nvme_fc_lport_put(lport);
    }
    #endif
}
```

#### Marginal → Online Transition:
```c
if (rport->port_state == FC_PORTSTATE_MARGINAL) {
    rport->port_state = port_state;
    
    #if (IS_ENABLED(CONFIG_NVME_FC))
    // Cross-layer integration: notify NVMe-FC layer
    struct Scsi_Host *shost = rport_to_shost(rport);
    u64 local_wwpn = fc_host_port_name(shost);
    
    lport = nvme_fc_lport_from_wwpn(local_wwpn);
    if (lport) {
        nvme_fc_fpin_set_state(lport, rport->port_name, false);
        nvme_fc_lport_put(lport);
    }
    #endif
}
```

### 2. Function Registration Chain
```
fc_attach_transport()
├── Setup rport attributes
│   └── SETUP_PRIVATE_RPORT_ATTRIBUTE_RW(port_state)  [line 2716]
│       └── Creates device_attr_rport_port_state
│           └── FC_DEVICE_ATTR(rport, port_state, 0444|0200, 
│               show_fc_rport_port_state, fc_rport_set_marginal_state)
│               └── __ATTR(port_state, 0644, show_func, store_func)
│
└── transport_container_register(&i->rport_attr_cont)  [line 2631]
    └── Registers attributes with sysfs
```

### 3. **NEW: NVMe-FC Helper Functions**

#### nvme_fc_lport_from_wwpn() - Cross-Layer Bridge Function:
```c
struct nvme_fc_lport *nvme_fc_lport_from_wwpn(u64 wwpn)
{
    // Thread-safe search through global NVMe-FC local port list
    // Returns lport with incremented reference count
    // Caller must call nvme_fc_lport_put() for cleanup
}
```

#### nvme_fc_fpin_set_state() - Enhanced State Control:
```c
void nvme_fc_fpin_set_state(struct nvme_fc_lport *lport, u64 wwpn, bool marginal)
{
    // Enhanced to support both setting and clearing marginal state
    // marginal=true:  set_bit(NVME_CTRL_MARGINAL)
    // marginal=false: clear_bit(NVME_CTRL_MARGINAL) 
}
```

### 4. Macro Expansions

#### FC_DEVICE_ATTR Macro (line 66):
```c
#define FC_DEVICE_ATTR(_prefix,_name,_mode,_show,_store)
struct device_attribute device_attr_##_prefix##_##_name = 
    __ATTR(_name,_mode,_show,_store)
```

#### fc_enum_name_match Macro (line 85):
```c
#define fc_enum_name_match(title, table_type, table)
static int get_fc_##title##_match(const char *table_key, enum table_type *value)
{
    // Searches through table array comparing strings
    for (i = 0; i < ARRAY_SIZE(table); i++) {
        if (strncmp(table_key, table[i].name, table[i].matchlen) == 0) {
            *value = table[i].value;
            return 0; /* success */
        }
    }
    return 1; /* failure */
}
```

### 5. Data Structures Used
```
fc_port_state_names[] table (lines 153-166):
├── FC_PORTSTATE_UNKNOWN     → "Unknown"
├── FC_PORTSTATE_NOTPRESENT  → "Not Present"  
├── FC_PORTSTATE_ONLINE      → "Online"      ← Valid transition target
├── FC_PORTSTATE_OFFLINE     → "Offline"
├── FC_PORTSTATE_BLOCKED     → "Blocked"
├── FC_PORTSTATE_BYPASSED    → "Bypassed"
├── FC_PORTSTATE_DIAGNOSTICS → "Diagnostics"
├── FC_PORTSTATE_LINKDOWN    → "Linkdown"
├── FC_PORTSTATE_ERROR       → "Error"
├── FC_PORTSTATE_LOOPBACK    → "Loopback"
├── FC_PORTSTATE_DELETED     → "Deleted"
└── FC_PORTSTATE_MARGINAL    → "Marginal"    ← Valid transition target
```

## Enhanced Function Behavior

### Allowed State Transitions with NVMe-FC Integration
1. **Online → Marginal**: 
   - **SCSI Layer**: Updates `rport->port_state = FC_PORTSTATE_MARGINAL`
   - **NVMe-FC Layer**: Calls `nvme_fc_fpin_set_state(lport, rport->port_name, true)`
   - **Result**: `set_bit(NVME_CTRL_MARGINAL, &ctrl->ctrl.flags)` for affected controllers

2. **Marginal → Online**: 
   - **SCSI Layer**: Updates `rport->port_state = FC_PORTSTATE_ONLINE`
   - **NVMe-FC Layer**: Calls `nvme_fc_fpin_set_state(lport, rport->port_name, false)` 
   - **Result**: `clear_bit(NVME_CTRL_MARGINAL, &ctrl->ctrl.flags)` for affected controllers

3. **Any other transitions**: Rejected with -EINVAL

### Cross-Layer Synchronization
- **Conditional Compilation**: NVMe-FC integration only active when `CONFIG_NVME_FC=y`
- **Reference Counting**: Proper lport lifecycle management prevents use-after-free
- **Thread Safety**: All operations use appropriate locking mechanisms
- **Error Resilience**: NVMe-FC integration failures don't affect SCSI layer operations

### Error Cases
- Invalid input string → -EINVAL
- Attempt to transition from/to invalid states → -EINVAL
- get_fc_port_state_match() failure → -EINVAL
- **NEW**: NVMe-FC lport lookup failure → Silent (operation continues for SCSI layer)
- **NEW**: Missing nvme_fc_lport_put() → Reference leak (but handled gracefully)

## Sysfs Interface

**Path**: `/sys/class/fc_rport/rport-X:Y-Z/port_state`
**Permissions**: 0644 (read/write for owner, read for group/others)
**Usage**:
```bash
# Read current state
cat /sys/class/fc_rport/rport-2:0-1/port_state

# Set to marginal (if currently online)
echo "Marginal" > /sys/class/fc_rport/rport-2:0-1/port_state

# Set to online (if currently marginal)  
echo "Online" > /sys/class/fc_rport/rport-2:0-1/port_state
```

## Integration Points
- **SCSI Transport Layer**: Part of FC transport template registration
- **Device Model**: Integrated with Linux device model via transport containers
- **Sysfs**: Exposes FC remote port state management to userspace
- **FC Drivers**: Used by FC HBA drivers for remote port state management
- **NEW: NVMe-FC Transport Layer**: Cross-layer integration for coordinated port state management
- **NEW: NVMe Multipath**: Marginal controller flags influence path selection algorithms
- **NEW: Reference Counting**: Proper lifecycle management across transport layers

## Files Involved
1. `drivers/scsi/scsi_transport_fc.c` - **Enhanced** main implementation with NVMe-FC integration
2. `include/scsi/scsi_transport_fc.h` - Header with macro definitions  
3. `/sys/class/fc_rport/` - Sysfs interface exposure
4. **NEW**: `drivers/nvme/host/fc.c` - NVMe-FC transport layer with new helper functions
5. **NEW**: `include/linux/nvme-fc-driver.h` - NVMe-FC function declarations

## Key Enhancements Summary

### **What Changed:**
1. **Cross-Layer Communication**: SCSI FC transport now communicates with NVMe-FC transport
2. **Bidirectional State Control**: Enhanced `nvme_fc_fpin_set_state()` supports both set/clear operations  
3. **Helper Functions**: New `nvme_fc_lport_from_wwpn()` bridges SCSI and NVMe-FC layers
4. **Reference Management**: Exported `nvme_fc_lport_put()` for proper cleanup
5. **Conditional Integration**: NVMe-FC calls bracketed with `#if (IS_ENABLED(CONFIG_NVME_FC))`

### **Why It Matters:**
- **Unified Port Management**: Single sysfs interface controls both SCSI and NVMe-FC protocols
- **Consistent Behavior**: Port states synchronized across all protocols sharing FC infrastructure  
- **Multipath Optimization**: NVMe multipath can make informed decisions based on port health
- **Fabric Awareness**: Both SCSI and NVMe layers receive coordinated fabric performance information

### **Architecture Impact:**
- **Layered Design**: Maintains proper separation while enabling cross-layer coordination
- **Backward Compatibility**: All existing SCSI-only functionality preserved
- **Forward Compatibility**: Framework ready for additional FC4 protocol integration
- **Performance**: Minimal overhead when NVMe-FC not configured
